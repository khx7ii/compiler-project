options {
    STATIC = false;
    IGNORE_CASE = false;

}
PARSER_BEGIN(JavaParser)
package parser;
import parser.SymbolTable;import java.util.*;
import java.io.*;
import parser.ASTNode;

public class JavaParser {
    // Use external parser.SymbolTable class
    private SymbolTable symbolTable = new SymbolTable();

    // Helper method to get clean token name
    private String getTokenName(Token token) {
        String name = tokenImage[token.kind];
            if (name.equals("\"<\"") || name.equals("\">\"") || name.equals("\"<=\"") || name.equals("\">=\"")) {
                return "Operator";  // Keep the operator as is (without any cleaning)
            }
        name = name.replace("\"", "").replace("<","").replace(">","") ;

        // Map to token type names
    switch (name) {
            case "class": case "public": case "private": case"protected":
            case"final": case"const": case "static": case "void": case "int":
            case "double": case "float": case "long": case "short": case "byte":
            case "char": case "boolean": case "if": case "else": case "while": case "do":
            case "for": case "return": case "break": case "continue": case "true": case "false":
            case "switch": case "case" : case "default":
                return "Keyword";

            case "=": case "+": case "-": case "*": case "/": case "%": case "==": case "!=": case "<":
            case ">": case "<=": case ">=": case "&&": case "||": case "!": case "++": case "--":
                return "Operator";

            case "(": case ")": case "{": case "}": case "[":
            case "]": case ";": case ",": case ".": case ":":
                return "Special character";

            case "SINGLE_LINE_COMMENT":
            case "MULTI_LINE_COMMENT":
                return "Comment";

            case "STRING_LITERAL":
            case "CHAR_LITERAL":
                return "Character Constant";

            case "INTEGER_LITERAL":
            case "LONG_LITERAL":
            case "FLOAT_LITERAL":
            case "DOUBLE_LITERAL":
                return "Numeric Constant";

            default:
                return name;
        }
    }
    private void recordSpecialTokens(Token t) {
        Token special = t.specialToken;
        while (special != null) {
            symbolTable.addToken(special, "Comment");
            special = special.specialToken;
        }
    }
    private void recordToken(Token t) {
        recordSpecialTokens(t);
        symbolTable.addToken(t, getTokenName(t));
    }
    public SymbolTable getSymbolTable() {
        return this.symbolTable;
    }
    public void printSymbolTable() {
        symbolTable.printSymbolTable();
    }


    public List<String> getUnusedVariables() {
        return symbolTable.getUnusedVariables();
        }

    private static void checkDivisionInAST(ASTNode node) {
        if (node == null) return;

        if (node instanceof BinaryOpNode) {
            BinaryOpNode binOp = (BinaryOpNode) node;
            if ((binOp.getOperator().equals("/") || binOp.getOperator().equals("%"))) {
                if (binOp.getRight() instanceof LiteralNode) {
                    LiteralNode literal = (LiteralNode) binOp.getRight();
                    String value = literal.getValue().toLowerCase().replaceAll("[lfd]$", "");
                    try {
                        double numValue = Double.parseDouble(value);
                        if (numValue == 0.0) {
                            throw new RuntimeException(
                                "runtime error! at line " + binOp.line +
                                ", column " + binOp.column + " . Division/Modulo by zero"
                            );
                        }
                    } catch (NumberFormatException e) {
                        // Ignore
                    }
                }
            }
            checkDivisionInAST(binOp.getLeft());
            checkDivisionInAST(binOp.getRight());
        } else if (node instanceof ProgrameNode) {
            ProgrameNode prog = (ProgrameNode) node;
            for (ASTNode child : prog.getClasses()) {
                checkDivisionInAST(child);
            }
        } else if (node instanceof ClassNode) {
            ClassNode cls = (ClassNode) node;
            for (ASTNode member : cls.getMembers()) {
                checkDivisionInAST(member);
            }
        } else if (node instanceof MethodNode) {
            MethodNode method = (MethodNode) node;
            for (ASTNode stmt : method.getStatements()) {
                checkDivisionInAST(stmt);
            }
        } else if (node instanceof BlockNode) {
            BlockNode block = (BlockNode) node;
            for (ASTNode stmt : block.getStatements()) {
                checkDivisionInAST(stmt);
            }
        } else if (node instanceof IfNode) {
            IfNode ifNode = (IfNode) node;
            checkDivisionInAST(ifNode.getCondition());
            checkDivisionInAST(ifNode.getThenStatement());
            checkDivisionInAST(ifNode.getElseStatement());
        } else if (node instanceof WhileNode) {
            WhileNode whileNode = (WhileNode) node;
            checkDivisionInAST(whileNode.getCondition());
            checkDivisionInAST(whileNode.getBody());
        } else if (node instanceof DoWhileNode) {
            DoWhileNode doWhile = (DoWhileNode) node;
            checkDivisionInAST(doWhile.getBody());
            checkDivisionInAST(doWhile.getCondition());
        } else if (node instanceof ForNode) {
            ForNode forNode = (ForNode) node;
            checkDivisionInAST(forNode.getInit());
            checkDivisionInAST(forNode.getCondition());
            checkDivisionInAST(forNode.getUpdate());
            checkDivisionInAST(forNode.getBody());
        } else if (node instanceof SwitchNode) {
            SwitchNode switchNode = (SwitchNode) node;
            checkDivisionInAST(switchNode.getExpression());
            for (ASTNode caseNode : switchNode.getCases()) {
                checkDivisionInAST(caseNode);
            }
            checkDivisionInAST(switchNode.getDefaultCase());
        } else if (node instanceof CaseNode) {
            CaseNode caseNode = (CaseNode) node;
            checkDivisionInAST(caseNode.getValue());
            for (ASTNode stmt : caseNode.getStatements()) {
                checkDivisionInAST(stmt);
            }
        } else if (node instanceof DefaultCaseNode) {
            DefaultCaseNode defaultCase = (DefaultCaseNode) node;
            for (ASTNode stmt : defaultCase.getStatements()) {
                checkDivisionInAST(stmt);
            }
        } else if (node instanceof ReturnNode) {
            ReturnNode returnNode = (ReturnNode) node;
            checkDivisionInAST(returnNode.getExpression());
        } else if (node instanceof AssignmentNode) {
            AssignmentNode assignment = (AssignmentNode) node;
            checkDivisionInAST(assignment.getExpression());
        } else if (node instanceof VariableDeclarationNode) {
            VariableDeclarationNode varDecl = (VariableDeclarationNode) node;
            checkDivisionInAST(varDecl.getInitializer());
        } else if (node instanceof UnaryOpNode) {
            UnaryOpNode unary = (UnaryOpNode) node;
            checkDivisionInAST(unary.getOperand());
        } else if (node instanceof MethodCallNode) {
            MethodCallNode methodCall = (MethodCallNode) node;
            for (ASTNode arg : methodCall.getArguments()) {
                checkDivisionInAST(arg);
            }
        }
    }

    private static void checkUselessStatements(ASTNode node) {
        if (node == null) return;

        if (node instanceof MethodNode) {
            MethodNode method = (MethodNode) node;
            for (ASTNode stmt : method.getStatements()) {
                // Check if statement is just an identifier or literal
                if (stmt instanceof IdentifierNode) {
                    System.err.println("WARNING: Line " + stmt.line +
                        " - Statement has no effect (unused variable reference '" +
                        ((IdentifierNode)stmt).getName() + "')");
                } else if (stmt instanceof LiteralNode) {
                    System.err.println("WARNING: Line " + stmt.line +
                        " - Statement has no effect (unused literal)");
                }
                checkUselessStatements(stmt);
            }
        } else if (node instanceof ClassNode) {
            ClassNode cls = (ClassNode) node;
            for (ASTNode member : cls.getMembers()) {
                checkUselessStatements(member);
            }
        } else if (node instanceof ProgrameNode) {
            ProgrameNode prog = (ProgrameNode) node;
            for (ASTNode cls : prog.getClasses()) {
                checkUselessStatements(cls);
            }
        }
    }
            public static void main(String[] args) {
                // Check if filename argument is provided

                if (args.length < 1) {
                    System.err.println("Usage: java Main <input_file.java>");
                    System.exit(1);
                }

                String filename = args[0];

                try {

                    System.out.println("Input file: " + filename);
                    System.out.println();

                    // Create parser with input file
                    FileInputStream fis = new FileInputStream(filename);
                    JavaParser parser = new JavaParser(fis);

                    ASTNode ast = parser.Program();

                    System.out.println();
                    System.out.println("SYNTAX VALIDATION SUCCESSFUL!");
                    System.out.println();



                    // Display symbol table (Phase 1)

                    parser.printSymbolTable();
                    System.out.println();

                    // Display AST (Phase 3)
                    System.out.println("========================================");
                    System.out.println("ABSTRACT SYNTAX TREE (AST)");
                    System.out.println("========================================");
                    ast.print(0);
                    ast.printTree("",true);
                    System.out.println();
                    // Check for unused variables
                        checkDivisionInAST(ast);

                    System.out.println("TYPE CHECKING");
                    System.out.println("========================================");
                    TypeChecker typeChecker = new TypeChecker(parser.getSymbolTable());
                    typeChecker.analyze(ast);
                    typeChecker.printResults();

                    // Exit if there are type errors
                    if (typeChecker.hasErrors()) {
                        System.err.println("Compilation failed due to type errors.");
                        System.exit(1);
                    }

                    java.util.List<String> unused = parser.getUnusedVariables();
                    if (!unused.isEmpty()) {
                        System.out.println("========================================");
                        System.out.println("WARNINGS: UNUSED VARIABLES");
                        System.out.println("========================================");
                        for (String var : unused) {
                            System.out.println(" -> " + var);
                        }
                        System.out.println();
                    }

                    // Close the input stream
                    fis.close();

                    // Summary

                    System.out.println("Phase 1 (Lexical Analysis): Complete");
                    System.out.println("Phase 2 (Syntax Analysis): Complete");
                    System.out.println("No syntax errors detected");
                    System.out.println();

                } catch (FileNotFoundException e) {
                    System.err.println("✗ ERROR: File '" + filename + "' not found.");
                    System.exit(1);

                } catch (ParseException e) {
                      // Handle syntax errors
                      System.err.println();
                      System.err.println("╔════════════════════════════════════════╗");
                      System.err.println("║    SYNTAX ERROR DETECTED               ║");
                      System.err.println("╚════════════════════════════════════════╝");
                      System.err.println();

                      int errorLine = e.currentToken.next.beginLine;
                      int errorColumn = e.currentToken.next.beginColumn;

                      System.err.println("Location: Line " + errorLine + ", Column " + errorColumn);
                      System.err.println();

                      // Try to read the problematic line from the file to analyze it
                      boolean isMissingReturnType = false;

                      try {
                          BufferedReader reader = new BufferedReader(new FileReader(filename));
                          String line = null;
                          int lineNum = 0;

                          // Read to the error line
                          while ((line = reader.readLine()) != null && lineNum < errorLine) {
                              lineNum++;
                              if (lineNum == errorLine) {
                                  // Check if this line matches the pattern of missing return type
                                  String trimmed = line.trim();

                                  // Pattern: starts with modifier(s) and has identifier followed by (
                                  // Examples: "public calculate(", "private static myMethod("
                                  if (trimmed.matches("^(public|private|protected|static)\\s+.*\\s+[a-zA-Z_][a-zA-Z0-9_]*\\s*\\(.*") ||
                                      trimmed.matches("^(public|private|protected|static)\\s+[a-zA-Z_][a-zA-Z0-9_]*\\s*\\(.*")) {

                                      // Check if it doesn't have a return type keyword
                                      if (!trimmed.matches(".*(void|int|long|short|byte|float|double|boolean|char|String)\\s+[a-zA-Z_][a-zA-Z0-9_]*\\s*\\(.*")) {
                                          isMissingReturnType = true;
                                      }
                                  }
                                  break;
                              }
                          }
                          reader.close();
                      } catch (Exception ex) {
                          // If we can't read file, just show generic error
                      }

                      if (isMissingReturnType) {
                          System.err.println("Error: Missing return type in method declaration");
                          System.err.println();
                          System.err.println("Hint: Every method in Java must have a return type.");
                          System.err.println("      If the method doesn't return a value, use 'void'.");
                          System.err.println();
                          System.err.println("Examples:");
                          System.err.println(" public void calculate() { ... }");
                          System.err.println(" public int calculate() { ... }");
                          System.err.println(" public calculate() { ... }  // Missing return type!");
                          System.err.println();
                      } else {
                          // Display generic error message
                          System.err.println("Error Message:");
                          System.err.println("  " + e.getMessage());
                          System.err.println();

                          // Try to provide more helpful context
                          if (e.currentToken != null && e.currentToken.next != null) {
                              System.err.println("Unexpected token: \"" + e.currentToken.next.image + "\"");
                              System.err.println();
                          }
                      }

                      System.exit(1);
                  }catch (TokenMgrError e) {
                    // Handle lexical errors (invalid tokens)
                    System.err.println();
                    System.err.println("╔════════════════════════════════════════╗");
                    System.err.println("║   ✗ LEXICAL ERROR DETECTED             ║");
                    System.err.println("╚════════════════════════════════════════╝");
                    System.err.println();
    String errorMsg = e.getMessage();

    // Check if it's an invalid identifier
    if (errorMsg.toLowerCase().contains("invalid") ||
        errorMsg.contains("INVALID_IDENTIFIER")) {

        System.err.println("Error: Invalid identifier detected");
        System.err.println();
        System.err.println("Details: " + errorMsg);
        System.err.println();
        System.err.println("Hint: Java identifiers cannot start with a digit.");
        System.err.println("      They must start with a letter, underscore (_), or dollar sign ($).");
        System.err.println();
        System.err.println("   int 10x;       // Invalid - starts with digit!");
        System.err.println();
    } else {
        System.err.println("Invalid token or character encountered");
        System.err.println();
        System.err.println("Error Message:");
        System.err.println("  " + errorMsg);
        System.err.println();
    }
                    System.exit(1);

                } catch (IOException e) {
                    System.err.println("✗ ERROR: Could not read file: " + e.getMessage());
                    System.exit(1);

                }catch ( RuntimeException e)
                {
                    System.err.println(e.getMessage());
                    System.exit(1);
                }catch (Exception e) {
                    System.err.println("✗ UNEXPECTED ERROR: " + e.getMessage());
                    e.printStackTrace();
                    System.exit(1);
                }
            }


}

PARSER_END(JavaParser)


/* ==================SKIP============*/
SKIP : {
  " " | "\t" | "\n" | "\r" | "\f"
}

SPECIAL_TOKEN : {
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")?>
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}
/* ==================TOKENS============*/

TOKEN : {
//KEYWORD
 <CLASS:"class">|<PUBLIC:"public">|<PRIVATE:"private">|<PROTECTED:"protected">
|<FINAL:"final">|<ABSTRACT:"abstract">|<CONST:"const">|<STATIC:"static">
|<VOID:"void">|<INT:"int">|<LONG:"long">|<SHORT:"short">|<BYTE:"byte">
|<FLOAT:"float">|<DOUBLE:"double">|<STRING:"String">|<CHAR:"char">
|<BOOLEAN:"boolean">|<IF:"if">|<ELSE:"else">|<WHILE:"while">
|<DO:"do">|<FOR:"for">|<RETURN:"return">|<TRUE:"true">
|<FALSE:"false">|<NEW:"new">|<THIS:"this">|<BREAK:"break">
|<CONTINUE:"continue">|<SWITCH: "switch">|<CASE:"case">|<DEFAULt:"default">
}

TOKEN : {
//OPERATORS
 <ASSIGN:"=">|<PLUS:"+">|<MINUS:"-">|<DIVIDE:"/">
|<MULTIPLY:"*">|<MODULO:"%">|<EQ:"==">|<NE:"!=">
|<LT:"<">|<LE:"<=">|<GT:">">|<GE:">=">|<AND:"&&">
|<OR:"||">|<NOT:"!">|<INCREMENT:"++">|<DECREMENT:"--">
}

TOKEN : {
//DELIMITERS
  <LPAREN: "(">| <RPAREN: ")">| <LBRACE: "{">| <RBRACE: "}">
| <LBRACKET: "[">| <RBRACKET: "]">| <SEMICOLON: ";">| <COMMA: ",">
| <DOT: ".">| <COLON:":">
}



TOKEN : {
//
//LITERAL - Modified to catch invalid identifiers
  <INTEGER_LITERAL: (["0"-"9"])+>
| <LONG_LITERAL: (["0"-"9"])+ ("l"|"L")>
| <FLOAT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])+ ("f"|"F") | (["0"-"9"])+ ("f"|"F")>
| <DOUBLE_LITERAL: (["0"-"9"])+ "." (["0"-"9"])+| (["0"-"9"])+ "." (["0"-"9"])+ ("d"|"D")>
| <STRING_LITERAL: "\"" (~["\"","\\"] | "\\" ~[])* "\"">
| <CHAR_LITERAL: "'" (~["'","\\"] | "\\" ~[]) "'">
| <BOOLEAN_LITERAL: "true" | "false">
| <NULL_LITERAL: "null">
}
TOKEN : {
  <IDENTIFIER: ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","0"-"9","_"])*>
}
SPECIAL_TOKEN : {
  <INVALID_ID: (["0"-"9"])+ (["a"-"z","A"-"Z","_"]) (["a"-"z","A"-"Z","0"-"9","_"])*> {
    throw new TokenMgrError(
      "Lexical error at line " + input_stream.getBeginLine() +
      ", column " + input_stream.getBeginColumn() +
      ": Invalid identifier '" + image.toString() + "' - identifiers cannot start with a digit",
      TokenMgrError.LEXICAL_ERROR
    );
  }
}
///=====================phase2:parsing====================///

ASTNode Program():{
 ASTNode classDecl;
 ProgrameNode program = new ProgrameNode();
 }
{
(classDecl= ClassDeclaration()
   { program.addClass(classDecl); })+
<EOF>
{
return program;
}
}

ASTNode ClassDeclaration():{
        Token tCLASS,className,tRBRACE,tLBRACE;
        String modifiers = "";
        ClassNode classNode;
        ASTNode member;
        }
{
 [ modifiers = Modifiers() ]
 tCLASS=<CLASS> className =<IDENTIFIER>
    {
recordToken(tCLASS);
recordToken(className);
        classNode = new ClassNode(className.image,modifiers, className.beginLine, className.beginColumn);
 }
tLBRACE=<LBRACE>{recordToken(tLBRACE);}
(member=MemberDeclaration()
{classNode.addMember(member);})*
tRBRACE=<RBRACE>
{recordToken(tRBRACE);
 return classNode;
}
}

ASTNode MemberDeclaration() : {
            ASTNode node;}
{
(
    LOOKAHEAD(Modifiers() Type() [<LBRACKET> <RBRACKET>] <IDENTIFIER> <SEMICOLON>)
    node=FieldDeclaration()
|   LOOKAHEAD(Modifiers() Type() [<LBRACKET> <RBRACKET>] <IDENTIFIER> <LPAREN>)
    node=MethodDeclaration()
|   LOOKAHEAD(Modifiers() <VOID> <IDENTIFIER> <LPAREN>)
    node=MethodDeclaration()
|   LOOKAHEAD(Type() [<LBRACKET> <RBRACKET>] <IDENTIFIER> <SEMICOLON>)
    node=FieldDeclaration()
|   LOOKAHEAD(Type() [<LBRACKET> <RBRACKET>] <IDENTIFIER> <LPAREN>)
    node=MethodDeclaration()
|   LOOKAHEAD(<VOID> <IDENTIFIER> <LPAREN>)
    node=MethodDeclaration()
)
    {return node;}
}

ASTNode FieldDeclaration():{
        Token type,id,tSEMICOLON,tLBRACKET,tRBRACKET;
        String modifiers = "";
            boolean isArray = false;

}
        {
         [ modifiers = Modifiers() ]
        type= Type()
          [tLBRACKET=<LBRACKET> tRBRACKET=<RBRACKET> {
                                                        recordToken(tLBRACKET);
                                                        recordToken(tRBRACKET);
                                                        isArray = true;
                                                        }]
         id = <IDENTIFIER>  tSEMICOLON=<SEMICOLON>
{
    recordToken(type);
    recordToken(id);
    recordToken(tSEMICOLON);
    symbolTable.addVariable(id.image,type.image,id.beginLine);
    return new FieldNode(modifiers, type.image, id.image, isArray, id.beginLine, id.beginColumn);

}
        }

ASTNode MethodDeclaration():{
Token returnType,methodName,tRBRACE,tLBRACE,tLPAREN,tRPAREN;
    String modifiers = "";
    MethodNode methodNode ;
    List<ASTNode> params = new ArrayList<ASTNode>();
    List<ASTNode> statements = new ArrayList<ASTNode>();
    ASTNode param, stmt;
}
{
 [ modifiers = Modifiers() ]
 ( returnType = Type() | returnType = <VOID> )
 {
       recordToken(returnType);
 }
    methodName = <IDENTIFIER>
 {
        recordToken(methodName);

        methodNode = new MethodNode(modifiers, returnType.image, methodName.image,
                                            methodName.beginLine, methodName.beginColumn);

 }
    tLPAREN=<LPAREN>{recordToken(tLPAREN);}
    [param = Parameter() {params.add(param);} (<COMMA> param = Parameter() {params.add(param);})*]
    tRPAREN=<RPAREN>{recordToken(tRPAREN);}
    tLBRACE=<LBRACE>{recordToken(tLBRACE);}
    (stmt = Statement() {statements.add(stmt);})*
    tRBRACE=<RBRACE>{
       recordToken(tRBRACE);
       methodNode.setParameter(params);
       methodNode.setStatement(statements);
       return methodNode;
        }
}

ASTNode Parameter():{
    Token type,id,tLBRACKET,tRBRACKET;
    boolean isArray = false;
}
{
    type = Type(){recordToken(type);}
    [
       tLBRACKET=<LBRACKET> tRBRACKET=<RBRACKET>
       {recordToken(tLBRACKET);
        recordToken(tRBRACKET);
        isArray=true;
        }]  // Optional array brackets
  id =<IDENTIFIER>
  {

        recordToken(id);
        symbolTable.addVariable(id.image,type.image,id.beginLine);
        return new ParameterNode(type.image, id.image, isArray, id.beginLine, id.beginColumn);

 }
}
Token Type():{
        Token t;}
        {
        (t=<INT> | t= <LONG> |t=<SHORT> |t=<BYTE> |t=<DOUBLE> |t=<FLOAT> |t=<BOOLEAN> |t=<CHAR>|t=<STRING> )
        {return t;}
        }
String Modifiers() :
{
    Token mod;
    List<String> modList = new ArrayList<String>();
}
{
    (
        ( mod = <PUBLIC> | mod = <PRIVATE> | mod = <PROTECTED> | mod = <STATIC> )
        {
            recordToken(mod);
            modList.add(mod.image);
        }
    )+
    {
        return String.join(" ", modList);
    }
}
ASTNode Statement():{
 ASTNode node;}
{
    (
            node = IfStatement()
        |   node = ForStatement()
        |   node = WhileStatement()
        |   node = DoWhileStatement()
        |   node = ReturnStatement()
        |   node = Block()
        |   node = BreakStatement()
        |   node = ContinueStatement()
        |   node = SwitchStatement()
        |   LOOKAHEAD(Type() [<LBRACKET><RBRACKET>] <IDENTIFIER>)
            node = VariableDeclaration()
        |   LOOKAHEAD(<IDENTIFIER> <ASSIGN>)
            node = AssignmentStatement()
        |   node = StatementExpression()
        )
        { return node; }

}
ASTNode StatementExpression() : {
   ASTNode node;
     Token tSEMICOLON;
 }
{
    (
        LOOKAHEAD(<IDENTIFIER> <DOT>)
        node = MemberAccess()
    |   LOOKAHEAD(<IDENTIFIER> <LPAREN>)
        node = MethodCall()
    |   LOOKAHEAD(<IDENTIFIER> <INCREMENT>)
        node = PostIncrementExpression()
    |   LOOKAHEAD(<IDENTIFIER> <DECREMENT>)
        node = PostDecrementExpression()
    |   LOOKAHEAD(<INCREMENT> <IDENTIFIER>)
        node = PreIncrementExpression()
    |   LOOKAHEAD(<DECREMENT> <IDENTIFIER>)
        node = PreDecrementExpression()
    )
    tSEMICOLON=<SEMICOLON>
    {recordToken(tSEMICOLON);
     return node; }
}

ASTNode VariableDeclaration():{
    Token type, id, tAssign, tSEMICOLON, tLBRACKET, tRBRACKET;
    boolean isArray = false;
    ASTNode initializer = null;
}
{
    type =Type() {recordToken(type);}
    [
        tLBRACKET=<LBRACKET> tRBRACKET=<RBRACKET>
        {recordToken(tLBRACKET);
         recordToken(tRBRACKET);
         isArray = true;

         }]
         id=<IDENTIFIER>
        {
         recordToken(id);
         symbolTable.addVariable(id.image, type.image, id.beginLine);
}
    [tAssign = <ASSIGN> {recordToken(tAssign);} initializer = Expression()]
        tSEMICOLON=<SEMICOLON>
        {recordToken(tSEMICOLON);
         return new VariableDeclarationNode(type.image, id.image, isArray, initializer,
                                          id.beginLine, id.beginColumn);

}
        }
ASTNode AssignmentStatement():{
        Token id,tAssign,tSEMICOLON;
            ASTNode expr;
}
{
        id=<IDENTIFIER> tAssign=<ASSIGN>

        {
            recordToken(id);
            recordToken(tAssign);

                     symbolTable.markVariableUsed(id.image);
                 }

         expr=Expression()
         tSEMICOLON=<SEMICOLON>
        {
         recordToken(tSEMICOLON);
         return new AssignmentNode(id.image, expr, id.beginLine, id.beginColumn);
         }

        }
ASTNode IfStatement():{
            Token tIf,tElse,tLPAREN,tRPAREN;
            ASTNode condition, thenStmt, elseStmt = null;
}
{
tIf=<IF>
{
    recordToken(tIf);
}
    tLPAREN=<LPAREN>{recordToken(tLPAREN);}
    condition = Expression()
    tRPAREN=<RPAREN>{recordToken(tRPAREN);}
    thenStmt = Statement()
[
    tElse=<ELSE>{recordToken(tElse);}
    elseStmt = Statement() ]
    {
        return new IfNode(condition, thenStmt, elseStmt, tIf.beginLine, tIf.beginColumn);
    }
}
ASTNode WhileStatement():{
            Token t,tLPAREN,tRPAREN;
            ASTNode condition, body;
}
{
    t=<WHILE>
    {
         recordToken(t);
    }
    tLPAREN=<LPAREN>{recordToken(tLPAREN);}
    condition = Expression()
    tRPAREN=<RPAREN>{recordToken(tRPAREN);}
    body = Statement()
    {
        return new WhileNode(condition, body, t.beginLine, t.beginColumn);
    }
}
ASTNode DoWhileStatement():{
        Token tDo,tWhile,tLPAREN,tRPAREN,tSEMI;
        ASTNode body, condition;
}
{
    tDo=<DO>
    {
        recordToken(tDo);
    }
    body = Statement()
    tWhile=<WHILE>{recordToken(tWhile);}
    tLPAREN=<LPAREN>{recordToken(tLPAREN);}
    condition = Expression()
    tRPAREN=<RPAREN>  tSEMI=<SEMICOLON>
    {
        recordToken(tRPAREN);
        recordToken(tSEMI);
        return new DoWhileNode(condition, body, tDo.beginLine, tDo.beginColumn);
}
}

ASTNode ForStatement(): {
        Token t,tLPAREN,tRPAREN,tSEMICOLON;
        ASTNode init = null, condition = null, update = null, body;
}
{
    t=<FOR>
    {
     recordToken(t);
}
     tLPAREN=<LPAREN>{recordToken(tLPAREN);}

     [init = ForInit()]
     tSEMICOLON=<SEMICOLON>{recordToken(tSEMICOLON);}
     [condition = Expression()]
     tSEMICOLON=<SEMICOLON>{recordToken(tSEMICOLON);}
     [update = ForUpdate()]
     tRPAREN=<RPAREN>{recordToken(tRPAREN);}
     body = Statement()
     {
        return new ForNode(init, condition, update, body, t.beginLine, t.beginColumn);
     }
}

ASTNode ForInit():{
    ASTNode node;
}
{
(   LOOKAHEAD(Type() <IDENTIFIER> )
    node = VariableDeclarationWithoutSemicolon()
|   node = AssignmentWithoutSemicolon()
)
    {return node ;}
}
ASTNode VariableDeclarationWithoutSemicolon() :
{
    Token type, id,tAssign;
    ASTNode initializer = null;
}
{
    type = Type() id = <IDENTIFIER>
    {
        recordToken(type);
        recordToken(id);
        symbolTable.addVariable(id.image, type.image, id.beginLine);
    }
    [ tAssign=<ASSIGN> {recordToken(tAssign);} initializer = Expression() ]
    {
        return new VariableDeclarationNode(type.image, id.image, false, initializer,
                                          id.beginLine, id.beginColumn);
    }
}

ASTNode AssignmentWithoutSemicolon() :
{
    Token id,tAssign;
    ASTNode expr;
}
{
    id = <IDENTIFIER>
    {
        recordToken(id);
        symbolTable.markVariableUsed(id.image);
    }
    tAssign=<ASSIGN> {recordToken(tAssign);}
    expr = Expression()
    {
        return new AssignmentNode(id.image, expr, id.beginLine, id.beginColumn);
    }
}
ASTNode ForUpdate():{
    ASTNode node;
}
{
(
    LOOKAHEAD(<IDENTIFIER> <ASSIGN>)
    node = AssignmentWithoutSemicolon()
|   LOOKAHEAD(<IDENTIFIER> <INCREMENT>)
    node = PostIncrementExpressionWithoutSemicolon()
|   LOOKAHEAD(<IDENTIFIER> <DECREMENT>)
    node = PostDecrementExpressionWithoutSemicolon()
|   LOOKAHEAD(<INCREMENT> <IDENTIFIER>)
    node = PreIncrementExpressionWithoutSemicolon()
|   LOOKAHEAD(<DECREMENT> <IDENTIFIER>)
    node = PreDecrementExpressionWithoutSemicolon()
)
    { return node; }
}
ASTNode PostIncrementExpressionWithoutSemicolon() :
{
    Token id,tINC;
}
{
    id = <IDENTIFIER> tINC=<INCREMENT>
    {
        recordToken(id);
        recordToken(tINC);
        symbolTable.markVariableUsed(id.image);
        return new UnaryOpNode("++", new IdentifierNode(id.image, id.beginLine, id.beginColumn),
                               false, id.beginLine, id.beginColumn);
    }
}

ASTNode PostDecrementExpressionWithoutSemicolon() :
{
    Token id,tDEC;
}
{
    id = <IDENTIFIER> tDEC=<DECREMENT>
    {
        recordToken(id);
        recordToken(tDEC);
        symbolTable.markVariableUsed(id.image);
        return new UnaryOpNode("--", new IdentifierNode(id.image, id.beginLine, id.beginColumn),
                               false, id.beginLine, id.beginColumn);
    }
}

ASTNode PreIncrementExpressionWithoutSemicolon() :
{
    Token id,tINC;
}
{
    tINC=<INCREMENT> id = <IDENTIFIER>
    {
        recordToken(tINC);
        recordToken(id);
        symbolTable.markVariableUsed(id.image);
        return new UnaryOpNode("++", new IdentifierNode(id.image, id.beginLine, id.beginColumn),
                               true, id.beginLine, id.beginColumn);
    }
}

ASTNode PreDecrementExpressionWithoutSemicolon() :
{
    Token id,tDEC;
}
{
    tDEC=<DECREMENT> id = <IDENTIFIER>
    {
        recordToken(tDEC);
        recordToken(id);
        symbolTable.markVariableUsed(id.image);
        return new UnaryOpNode("--", new IdentifierNode(id.image, id.beginLine, id.beginColumn),
                                      true, id.beginLine, id.beginColumn);
    }
}

ASTNode ReturnStatement():{
    Token t,tSEMICOLON;
    ASTNode expr;
}
{
    t=<RETURN>
    {
        recordToken(t);
}

    expr = Expression()
    tSEMICOLON=<SEMICOLON>
    {
        recordToken(tSEMICOLON);
        return new ReturnNode(expr, t.beginLine, t.beginColumn);
    }
}
ASTNode Block(): {
   Token tRBRACE,tLBRACE;
    List<ASTNode> statements = new ArrayList<ASTNode>();
    ASTNode stmt;
}
{
    tLBRACE=<LBRACE>{recordToken(tLBRACE);}
    (stmt = Statement() {statements.add(stmt);})*
    tRBRACE=<RBRACE>
    {
        recordToken(tRBRACE);
        return new BlockNode(statements, tLBRACE.beginLine, tLBRACE.beginColumn);
}

}
ASTNode BreakStatement():{
    Token t,tSEMICOLON;
}
{
    t=<BREAK>{recordToken(t);}
    tSEMICOLON=<SEMICOLON>
    {
        recordToken(tSEMICOLON);
        return new BreakNode(t.beginLine, t.beginColumn);
}
}
ASTNode ContinueStatement() : {
    Token t, tSEMICOLON;
}
{
    t=<CONTINUE> {recordToken(t);}
    tSEMICOLON=<SEMICOLON>
    {
        recordToken(tSEMICOLON);
        return new ContinueNode(t.beginLine, t.beginColumn);
    }
}

ASTNode SwitchStatement() : {
    Token t, tLPAREN, tRPAREN, tRBRACE, tLBRACE;
    ASTNode expr;
    SwitchNode switchNode;
    ASTNode caseNode, defaultNode = null;
}
{
    t=<SWITCH>
    {
        recordToken(t);
    }
    tLPAREN=<LPAREN>{recordToken(tLPAREN);}
    expr = Expression()
    tRPAREN=<RPAREN>{recordToken(tRPAREN);}
    tLBRACE=<LBRACE>
    {
        recordToken(tLBRACE);
        switchNode = new SwitchNode(expr, t.beginLine, t.beginColumn);
    }
    (
        caseNode = SwitchCase()
        {switchNode.addCase(caseNode);}
    )*
    [
        defaultNode = DefaultCase()
        {switchNode.setDefaultCase(defaultNode);}
    ]
    tRBRACE=<RBRACE>
    {
        recordToken(tRBRACE);
        return switchNode;
    }
}

ASTNode SwitchCase() : {
    Token t, tCOLON, caseValue;
    CaseNode caseNode;
    ASTNode value, stmt;
}
{
    t=<CASE>
    {
        recordToken(t);
    }
    (
        caseValue = <INTEGER_LITERAL> {value = new LiteralNode("int", caseValue.image, caseValue.beginLine, caseValue.beginColumn);}
    |   caseValue = <CHAR_LITERAL> {value = new LiteralNode("char", caseValue.image, caseValue.beginLine, caseValue.beginColumn);}
    |   caseValue = <STRING_LITERAL> {value = new LiteralNode("String", caseValue.image, caseValue.beginLine, caseValue.beginColumn);}
    |   caseValue = <IDENTIFIER> {value = new IdentifierNode(caseValue.image, caseValue.beginLine, caseValue.beginColumn);}
    )
    tCOLON=<COLON>
    {
        recordToken(tCOLON);
        caseNode = new CaseNode(value, t.beginLine, t.beginColumn);
    }
     (
        LOOKAHEAD({ getToken(1).kind != CASE && getToken(1).kind != DEFAULt && getToken(1).kind != RBRACE })
        stmt = Statement()
        {caseNode.addStatement(stmt);}
    )*
    {
        return caseNode;
    }}

ASTNode DefaultCase() : {
    Token t, tCOLON;
    DefaultCaseNode defaultNode;
    ASTNode stmt;
}
{
    t=<DEFAULt>
    {
        recordToken(t);
    }
    tCOLON=<COLON>
    {
        recordToken(tCOLON);
        defaultNode = new DefaultCaseNode(t.beginLine, t.beginColumn);
    }
    (
        LOOKAHEAD({ getToken(1).kind != RBRACE })
        stmt = Statement()
        {defaultNode.addStatement(stmt);}
    )*
    {
        return defaultNode;
    }}


ASTNode Expression() : {
    ASTNode node;
}
{
    node = LogicalOrExpression()
    { return node; }
}
ASTNode LogicalOrExpression() : {
    Token t;
    ASTNode left, right;
    }
    {
        left = LogicalAndExpression()
        (
            t=<OR> {recordToken(t);}
            right = LogicalAndExpression()
            { left = new BinaryOpNode("||", left, right, t.beginLine, t.beginColumn); }
        )*
        { return left; }
    }

ASTNode LogicalAndExpression() : {
        Token t;
        ASTNode left, right;
}
{
    left = EqualityExpression()
    (
        t=<AND> {recordToken(t);}
        right = EqualityExpression()
        { left = new BinaryOpNode("&&", left, right, t.beginLine, t.beginColumn); }
    )*
    { return left; }
}

ASTNode EqualityExpression() : {
    Token t;
    ASTNode left, right;
}
{
    left = RelationalExpression()
    (
        (t=<EQ> {recordToken(t);} | t=<NE> {recordToken(t);})
        right = RelationalExpression()
        { left = new BinaryOpNode(t.image, left, right, t.beginLine, t.beginColumn); }
    )*
    { return left; }
}
ASTNode RelationalExpression() : {
   Token t;
   ASTNode left, right;
}
{
    left = AdditiveExpression()
    (
        (t=<LT> {recordToken(t);} | t=<LE> {recordToken(t);} | t=<GT> {recordToken(t);} | t=<GE> {recordToken(t);})
        right = AdditiveExpression()
        { left = new BinaryOpNode(t.image, left, right, t.beginLine, t.beginColumn); }
    )*
    { return left; }
}

ASTNode AdditiveExpression() : {
   Token t;
   ASTNode left, right;
}
{
    left = MultiplicativeExpression()
    (
        (t=<PLUS> {recordToken(t);} | t=<MINUS> {recordToken(t);})
        right = MultiplicativeExpression()
        { left = new BinaryOpNode(t.image, left, right, t.beginLine, t.beginColumn); }
    )*
    { return left; }
}
ASTNode MultiplicativeExpression() : {
   Token t;
   ASTNode left, right;
}
{
    left = UnaryExpression()
    (
        (t=<MULTIPLY> {recordToken(t);} | t=<DIVIDE> {recordToken(t);}| t=<MODULO> {recordToken(t);})
        right = UnaryExpression()


        {
            left = new BinaryOpNode(t.image, left, right, t.beginLine, t.beginColumn); }
    )*
    { return left; }
}

ASTNode UnaryExpression() : {
    Token t;
    ASTNode operand;
}
{
    (t=<NOT> {recordToken(t);} | t=<MINUS> {recordToken(t);})
    operand = UnaryExpression()
    { return new UnaryOpNode(t.image, operand, true, t.beginLine, t.beginColumn); }
|   operand = PrimaryExpression()
    { return operand; }
}
ASTNode PostIncrementExpression() : {
        Token id, tINC;
}
{
        id = <IDENTIFIER> tINC=<INCREMENT>
        {
            recordToken(id);
            recordToken(tINC);
            symbolTable.markVariableUsed(id.image);
            return new UnaryOpNode("++", new IdentifierNode(id.image, id.beginLine, id.beginColumn),
                                  false, id.beginLine, id.beginColumn);
        }
}


ASTNode PostDecrementExpression() : {
    Token id, tDEC;
}
    {
        id = <IDENTIFIER> tDEC=<DECREMENT>
        {
            recordToken(id);
            recordToken(tDEC);
            symbolTable.markVariableUsed(id.image);
            return new UnaryOpNode("--", new IdentifierNode(id.image, id.beginLine, id.beginColumn),
                                  false, id.beginLine, id.beginColumn);
        }
    }

ASTNode PreIncrementExpression() : {
    Token tINC, id;
}
    {
        tINC=<INCREMENT> id = <IDENTIFIER>
        {
            recordToken(tINC);
            recordToken(id);
            symbolTable.markVariableUsed(id.image);
            return new UnaryOpNode("++", new IdentifierNode(id.image, id.beginLine, id.beginColumn),
                                  true, id.beginLine, id.beginColumn);
        }
    }

ASTNode PreDecrementExpression() : {
    Token tDEC, id;
}
    {
        tDEC=<DECREMENT> id = <IDENTIFIER>
        {
            recordToken(tDEC);
            recordToken(id);
            symbolTable.markVariableUsed(id.image);
            return new UnaryOpNode("--", new IdentifierNode(id.image, id.beginLine, id.beginColumn),
                                  true, id.beginLine, id.beginColumn);
        }
    }

ASTNode PrimaryExpression() : {
    Token t, tLPAREN, tRPAREN;
    ASTNode node;
}
    {
        t = <INTEGER_LITERAL>
        {
            recordToken(t);
            symbolTable.markVariableUsed(t.image);
            return new LiteralNode("int", t.image, t.beginLine, t.beginColumn);
        }
    |   t = <LONG_LITERAL>
        {
            recordToken(t);
            symbolTable.markVariableUsed(t.image);
            return new LiteralNode("long", t.image, t.beginLine, t.beginColumn);
        }
    |   t = <FLOAT_LITERAL>
        {
            recordToken(t);
            symbolTable.markVariableUsed(t.image);
            return new LiteralNode("float", t.image, t.beginLine, t.beginColumn);
        }
    |   t = <DOUBLE_LITERAL>
        {
            recordToken(t);
            symbolTable.markVariableUsed(t.image);
            return new LiteralNode("double", t.image, t.beginLine, t.beginColumn);
        }
    |   t = <STRING_LITERAL>
        {
            recordToken(t);
            symbolTable.markVariableUsed(t.image);
            return new LiteralNode("String", t.image, t.beginLine, t.beginColumn);
        }
    |   t = <CHAR_LITERAL>
        {
            recordToken(t);
            symbolTable.markVariableUsed(t.image);
            return new LiteralNode("char", t.image, t.beginLine, t.beginColumn);
        }
    |   t = <TRUE>
        {
            recordToken(t);
            symbolTable.markVariableUsed(t.image);
            return new LiteralNode("boolean", "true", t.beginLine, t.beginColumn);
        }
    |   t = <FALSE>
        {
            recordToken(t);
            symbolTable.markVariableUsed(t.image);
            return new LiteralNode("boolean", "false", t.beginLine, t.beginColumn);
        }
    |   LOOKAHEAD(<IDENTIFIER> <DOT>)
        node = MemberAccess()
        { return node; }
    |   LOOKAHEAD(<IDENTIFIER> <LPAREN>)
        node = MethodCall()
        { return node; }
    |   t = <IDENTIFIER>
        {
            recordToken(t);
            symbolTable.markVariableUsed(t.image);
            return new IdentifierNode(t.image, t.beginLine, t.beginColumn);
        }
    |   tLPAREN=<LPAREN> {recordToken(tLPAREN);}
        node = Expression()
        tRPAREN=<RPAREN>
        {recordToken(tRPAREN);
         return node;
        }

    }
ASTNode MemberAccess() : {
        Token id, tDot, tLPAREN, tRPAREN;
        MemberAccessNode memberNode;
        List<ASTNode> args = new ArrayList<ASTNode>();
        ASTNode arg;
}
    {
        id = <IDENTIFIER>
        {
            recordToken(id);
            memberNode = new MemberAccessNode(id.beginLine, id.beginColumn);
            memberNode.addMember(id.image);
        }
        (
            tDot=<DOT> {recordToken(tDot);}
            id = <IDENTIFIER>
            {
                recordToken(id);
                memberNode.addMember(id.image);
            }
            [
                tLPAREN=<LPAREN> {recordToken(tLPAREN);}
                [
                    arg = Expression() {args.add(arg);}
                    (<COMMA> arg = Expression() {args.add(arg);})*
                ]
                tRPAREN=<RPAREN>
                {
                    recordToken(tRPAREN);
                    MethodCallNode methodCall = new MethodCallNode(id.image, id.beginLine, id.beginColumn);
                    methodCall.setArguments(args);
                    memberNode.setMethodCall(methodCall);
                }
            ]
        )+
        { return memberNode; }
    }

ASTNode MethodCall() : {
        Token id, tLPAREN, tRPAREN;
        MethodCallNode methodCall;
        List<ASTNode> args = new ArrayList<ASTNode>();
        ASTNode arg;
    }
    {
        id = <IDENTIFIER>
        {
            recordToken(id);
            symbolTable.markVariableUsed(id.image);
            methodCall = new MethodCallNode(id.image, id.beginLine, id.beginColumn);
        }
        tLPAREN=<LPAREN> {recordToken(tLPAREN);}
        [
            arg = Expression() {args.add(arg);}
            (<COMMA> arg = Expression() {args.add(arg);})*
        ]
        tRPAREN=<RPAREN>
        {
            recordToken(tRPAREN);
            methodCall.setArguments(args);
            return methodCall;
        }
    }